_________________________________________________________________

Лаба 2





LD_LIBRARY_PATH, в которой перечисляются все каталоги содержащие пользовательские динамические библиотеки

 чтобы переходы в функциях библиотеки (операции goto на ассемблере) использовали не абсолютную адресацию, а относительную. То есть генерируемый компилятором код должен быть независимым от адресов, такая технология получила название PIC - Position Independent Code. В компиляторе gcc данная возможность включается ключом -fPIC. 



Динамическая библиотека это уже не архивный файл, а настоящая загружаемая программа, поэтому созданием динамических библиотек занимается сам компилятор gcc. Для того, чтобы создать динамическую библиотеку надо использовать ключ -shared: 



-c используется для процесса компиляции/ создать объектный файл

-o для компоновки /создать загрузычный файл

-l library	использовать библиотеку library.a при редактировании связей

-I dir 	добавить каталог dir в список поиска каталогов, содержащих include- файлы 

-L dir 	добавить директорию dir в список поиска библиотекки





Стек - это память, выделенная как пустое место для потока выполнения. Когда вызывается функция, блок резервируется в верхней части стека для локальных переменных и некоторых данных учета. Когда эта функция возвращается, блок становится неиспользуемым и может использоваться при следующем вызове функции. Стек всегда зарезервирован в порядке LIFO (последний в порядке очереди); последний зарезервированный блок всегда является следующим блоком, который должен быть освобожден. Это действительно упрощает отслеживание стека; освобождение блока из стека - это не более, чем настройка одного указателя.



Куча памяти выделяется для динамического выделения. В отличие от стека, нет принудительного шаблона для выделения и освобождения блоков из кучи; Вы можете выделить блок в любое время и освободить его в любое время. Это значительно усложняет отслеживание того, какие части кучи выделены или свободны в любой момент времени; Есть много пользовательских распределителей кучи, доступных для настройки производительности кучи для различных моделей использования.



Каждый поток получает стек, в то время как для приложения обычно есть только одна куча (хотя весьма часто иметь несколько куч для разных типов размещения).



Чтобы ответить на ваши вопросы напрямую:



    В какой степени они контролируются ОС или языковой средой выполнения?



ОС выделяет стек для каждого потока системного уровня при его создании. Обычно ОС вызывается языковой средой выполнения для выделения кучи для приложения.



    Какова их сфера применения?



Стек присоединен к потоку, поэтому, когда поток выходит из стека, он освобождается. Куча обычно выделяется при запуске приложения средой выполнения и восстанавливается при выходе из приложения (технически процесса).



    От чего зависит размер каждого из них?



Размер стека устанавливается при создании потока. Размер кучи устанавливается при запуске приложения, но может увеличиваться по мере необходимости (распределитель запрашивает больше памяти у операционной системы).



    Что делает быстрее?



Стек работает быстрее, потому что шаблон доступа упрощает выделение и освобождение памяти из него (указатель / целое число просто увеличивается или уменьшается), в то время как куча имеет гораздо более сложную бухгалтерию, связанную с выделением или освобождением. Кроме того, каждый байт в стеке имеет тенденцию использоваться очень часто, что означает, что он имеет тенденцию отображаться в кэш процессора, что делает его очень быстрым. Еще одним ударом по производительности для кучи является то, что куча, являющаяся главным образом глобальным ресурсом, как правило, должна быть многопоточной безопасной, то есть каждое распределение и освобождение должны быть - как правило - синхронизированы со «всеми» другими обращениями к куче в программе.





Препроцессинг



Эту операцию осуществляет текстовый препроцессор.



Исходный текст частично обрабатывается — производятся:



    Замена комментариев пустыми строками

    Текстовое включение файлов — #include

    Макроподстановки — #define

    Обработка директив условной компиляции — #if, #ifdef, #elif, #else, #endif



Компиляция



Процесс компиляции состоит из следующих этапов:



    Лексический анализ. Последовательность символов исходного файла преобразуется в последовательность лексем.

    Синтаксический анализ. Последовательность лексем преобразуется в дерево разбора.

    Семантический анализ. Дерево разбора обрабатывается с целью установления его семантики (смысла) — например, привязка идентификаторов к их декларациям, типам, проверка совместимости, определение типов выражений и т. д.

    Оптимизация. Выполняется удаление излишних конструкций и упрощение кода с сохранением его смысла.

    Генерация кода. Из промежуточного представления порождается объектный код.





Результатом компиляции является объектный код.



Компоновка

Также называется связывание, сборка или линковка.



Это последний этап процесса получения исполняемого файла, состоящий из связывания воедино всех объектных файлов проекта.



При этом возможны ошибки связывания.



Если, допустим, функция была объявлена, но не определена, ошибка обнаружится только на этом этапе.





Статическая библиотека - (*.a) собрана для непосредственного встраивания в Ваш исполняемый файл. Она просто будет помещена в соответствии с указанием linker'а. Тут будет статическая линковка.



Динамическая библиотека - (*.so) - будет просто подключаться как link на референс и не попадет в Ваш бинарь. Будет лишь указание где брать референс на тот или иной функционал. Тут будет динамическая линковка

_________________________________________________________________________